#!@@PYTHON@@

import argparse
import os
import sys

import makemehappy.build as build
import makemehappy.utilities as mmh
import makemehappy.toplevel as top

from logbook import warn, Logger, StreamHandler
from makemehappy.buildroot import BuildRoot
from makemehappy.cut import CodeUnderTest
from makemehappy.yamlstack import YamlStack, SourceStack


version = "@@VERSION@@"
fullname = "MakeMeHappy"
name = "mmh"

StreamHandler(sys.stdout).push_application()
log = Logger(fullname)

cfg = YamlStack(log, 'Configuration',
                mmh.dotFile('config.yaml'),
                mmh.xdgFile('config.yaml'),
                '@@ETCDIR@@/config.yaml',
                '@@DATADIR@@/config.yaml')

src = SourceStack(log, 'Source Definition',
                  mmh.dotFile('sources.yaml'),
                  mmh.xdgFile('sources.yaml'),
                  '@@ETCDIR@@/sources.yaml',
                  '@@DATADIR@@/sources.yaml')

ap = argparse.ArgumentParser()

ap.add_argument("-d", "--directory",
                default = None,
                help = "specify the build-root directory")

ap.add_argument("-m", "--module",
                default = "module.yaml",
                help = "specify the file that contains the"
                     + " module description (defaults to module.yaml)")

ap.add_argument("-p", "--preserve", action = "store_true",
                help = "preserve build root instead of deleting it")

ap.add_argument("-s", "--source",
                default = [ ],
                action = "append",
                help = "add a module source definition")

ap.add_argument("-V", "--version", action = "store_true",
                help = "show program version")

ap.add_argument("-v", "--verbose", action = "store_true",
                help = "produce verbose output")

ap.add_argument("rest",
                nargs = "*",
                default = [ ],
                help = "sub command to carry out")

cmdargs = ap.parse_args()

if (isinstance(cmdargs.directory, str)):
    cmdargs.preserve = not(cmdargs.preserve)

if (cmdargs.verbose):
    mmh.setVerbosity(1)

if (cmdargs.version):
    print("{} ({}) version {}".format(fullname, name, version))
    exit(0)

for item in cmdargs.source:
    if (os.path.isfile(item) == False):
        mmh.warn("Source definition does not exist: {}".format(item))
        exit(1)
    src.push(cmdargs.source)

cmd = mmh.lookupCommand(cmdargs.rest)

if (len(cmdargs.rest) == 0):
    cmd = 'build'
    cmdargs.rest = [ cmd ]
    log.info("Starting up using default command ({})".format(cmd))
elif (cmd != False):
    log.info("Starting up using '{}' command".format(cmd))

if (cmd == "build"):
    if (os.path.isfile(cmdargs.module) == False):
        mmh.warn("Module definition does not exist: {}".format(cmdargs.module))
        exit(1)

    cut = CodeUnderTest(log, cfg, src, cmdargs.module)
    cut.loadModule()
    cut.loadSources()
    cut.initRoot(cmdargs.directory)
    cut.populateRoot()
    cut.linkIntoRoot()
    cut.changeToRoot()
    cut.loadDependencies()
    cut.generateToplevel()
    cut.build()

    if (cmdargs.preserve == False):
        cut.cleanupRoot()

elif (cmd == "dump-description"):
    data = mmh.load(cmdargs.module)
    mmh.pp(data)

elif (isinstance(cmd, str)):
    print("Not implemented yet: {}".format(cmd))

else:
    mmh.warn("Unknown command: {}".format(cmdargs.rest[0]))
    exit(1)

exit(0)
