#!@@PYTHON@@

import argparse
import os
import sys

import makemehappy.build as build
import makemehappy.utilities as mmh
import makemehappy.toplevel as top

from logbook import warn, Logger, StreamHandler
from makemehappy.buildroot import BuildRoot
from makemehappy.cut import CodeUnderTest
from makemehappy.yamlstack import ConfigStack, SourceStack

version = "@@VERSION@@"
fullname = "MakeMeHappy"
name = "mmh"

StreamHandler(sys.stdout).push_application()
log = Logger(fullname)

cfg = ConfigStack(log, 'Configuration',
                  mmh.dotFile('config.yaml'),
                  mmh.xdgFile('config.yaml'),
                  '@@ETCDIR@@/config.yaml',
                  '@@DATADIR@@/config.yaml')

src = SourceStack(log, 'Source Definition',
                  mmh.dotFile('sources.yaml'),
                  mmh.xdgFile('sources.yaml'),
                  '@@ETCDIR@@/sources.yaml',
                  '@@DATADIR@@/sources.yaml')

ap = argparse.ArgumentParser()

ap.add_argument("-d", "--directory",
                default = None,
                help = "specify the build-root directory")

ap.add_argument("-m", "--module",
                default = "module.yaml",
                help = "specify the file that contains the"
                     + " module description (defaults to module.yaml)")

ap.add_argument("-p", "--preserve", action = "store_true",
                help = "preserve build root instead of deleting it")

ap.add_argument("-L", "--log-all", action = "store_true",
                help = "send all output to logging facility")

ap.add_argument("-l", "--log-to-file", action = "store_true",
                help = "log output to file (implies --log-all)")

ap.add_argument("-f", "--log-file",
                default = None,
                help = "specify log-file name to use")

ap.add_argument("-s", "--source",
                default = [ ],
                action = "append",
                help = "add a module source definition")

ap.add_argument("-V", "--version", action = "store_true",
                help = "show program version")

ap.add_argument("-v", "--verbose", action = "store_true",
                help = "produce verbose output")

ap.add_argument("rest",
                nargs = "*",
                default = [ ],
                help = "sub command to carry out")

cmdargs = ap.parse_args()

if (isinstance(cmdargs.directory, str)):
    cmdargs.preserve = not(cmdargs.preserve)

if (cmdargs.verbose):
    mmh.setVerbosity(1)

if (cmdargs.version):
    print("{} ({}) version {}".format(fullname, name, version))
    exit(0)

for item in cmdargs.source:
    if (os.path.isfile(item) == False):
        mmh.warn("Source definition does not exist: {}".format(item))
        exit(1)
    src.push(cmdargs.source)

def adjustConfig(cfg, args):
    layer = {}
    adjustments = 0
    if args.log_all == True:
        layer['log-all'] = not(cfg.lookup('log-all'))
        adjustments = adjustments + 1
    if args.log_to_file == True:
        layer['log-to-file'] = not(cfg.lookup('log-to-file'))
        adjustments = adjustments + 1
    if adjustments > 0:
        cfg.pushLayer(layer)

cmd = mmh.lookupCommand(cmdargs.rest)

if (len(cmdargs.rest) == 0):
    cmd = 'build'
    cmdargs.rest = [ cmd ]
    log.info("Starting up using default command ({})".format(cmd))
elif (cmd != False):
    log.info("Starting up using '{}' command".format(cmd))

if (cmd == "build"):
    if (os.path.isfile(cmdargs.module) == False):
        mmh.warn("Module definition does not exist: {}".format(cmdargs.module))
        exit(1)

    cfg.load()
    adjustConfig(cfg, cmdargs)
    cut = CodeUnderTest(log, cfg, src, cmdargs.module)
    cut.loadModule()
    cut.loadSources()
    cut.initRoot(cmdargs.directory)
    cut.populateRoot()
    cut.linkIntoRoot()
    cut.changeToRoot()
    cut.loadDependencies()
    cut.generateToplevel()
    cut.build()

    if (cmdargs.preserve == False):
        cut.cleanupRoot()

    cut.renderStatistics()
    if cut.wasSuccessful():
        log.info('All {} builds succeeded.'.format(cut.countBuilds()))
        exit(0)
    else:
        log.info('{} build(s) out of {} failed.'
                 .format(cut.countFailed(), cut.countBuilds()))
        exit(1)

elif (cmd == "dump-description"):
    data = mmh.load(cmdargs.module)
    mmh.pp(data)

elif (isinstance(cmd, str)):
    print("Not implemented yet: {}".format(cmd))

else:
    mmh.warn("Unknown command: {}".format(cmdargs.rest[0]))
    exit(1)

exit(0)
